var b=Object.defineProperty,k=Object.defineProperties;var I=Object.getOwnPropertyDescriptors;var m=Object.getOwnPropertySymbols;var R=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var y=(e,t,o)=>t in e?b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,s=(e,t)=>{for(var o in t||(t={}))R.call(t,o)&&y(e,o,t[o]);if(m)for(var o of m(t))h.call(t,o)&&y(e,o,t[o]);return e},a=(e,t)=>k(e,I(t));var f=(e,t)=>{var o={};for(var n in e)R.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&m)for(var n of m(e))t.indexOf(n)<0&&h.call(e,n)&&(o[n]=e[n]);return o};import{P as S,C as P}from"./vendor-227c15ea.js";const i=({key:e,name:t,rounds:o,showCards:n}={})=>({key:e||null,name:t||"",rounds:o||[{}],showCards:n||!1}),x=S.exports.Deta("b0ouklc5_23zArb8iPdWFe3ZQGbd7x86gjBedFbfo"),u=x.Base("planningPoker_Rooms"),p=()=>typeof window!="undefined",v=({rooms:e=[],currentRoom:t=i()}={})=>({rooms:e,currentRoom:t,cardPattern:p()&&localStorage.getItem("cardPattern")}),B=(()=>{let e=v();const{subscribe:t,set:o,update:n}=P(e);return t(r=>{e=r}),{subscribe:t,set:o,update:n,setCardPattern(r){if(!p())return;const c=localStorage.getItem("id"),l=e.currentRoom.rounds.length-1,d=e.currentRoom.rounds[l]||{};o(a(s({},e),{cardPattern:r})),localStorage.setItem("cardPattern",r),d[c]&&(console.log("playerId",c),this.chooseCard(d[c].value))},async fetchRooms(){return u.fetch().then(({items:r})=>o(a(s({},e),{rooms:r.map(i)})))},async saveRoom(r){const d=i(r),{key:c}=d,l=f(d,["key"]);return u.insert(l,c).finally(this.fetchRooms.bind(this))},async deleteRoom(r){return u.delete(r).finally(this.fetchRooms.bind(this))},async loadRoom(r){return u.get(r).then(c=>o(a(s({},e),{currentRoom:i(c)})))},async refreshCurrentRoom(){e.currentRoom.key&&this.loadRoom(e.currentRoom.key)},async toggleRevealCards(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{showCards:!e.currentRoom.showCards})});o(r),u.update({showCards:r.currentRoom.showCards},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async chooseCard(r){const c=localStorage.getItem("id"),l={playerName:localStorage.getItem("name"),pattern:e.cardPattern,value:r},d=e.currentRoom.rounds.length-1,g=e.currentRoom.rounds[d]||{},C=e.currentRoom.rounds.slice(0,d),w=a(s({},e),{currentRoom:a(s({},e.currentRoom),{rounds:[...C,a(s({},g),{[c]:l})]})});o(w),u.update({[`rounds[${d}].${c}`]:l},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async newRound(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{showCards:!1,rounds:[...e.currentRoom.rounds,{}]})});o(r),u.update({rounds:u.util.append({placeholder:!0}),showCards:!1},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))}}})();export{p as i,i as m,B as s};
