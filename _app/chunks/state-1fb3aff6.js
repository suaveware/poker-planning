var b=Object.defineProperty,k=Object.defineProperties;var S=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var R=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var f=(e,t,o)=>t in e?b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,s=(e,t)=>{for(var o in t||(t={}))R.call(t,o)&&f(e,o,t[o]);if(l)for(var o of l(t))h.call(t,o)&&f(e,o,t[o]);return e},a=(e,t)=>k(e,S(t));var y=(e,t)=>{var o={};for(var n in e)R.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&l)for(var n of l(e))t.indexOf(n)<0&&h.call(e,n)&&(o[n]=e[n]);return o};import{O as I,C as x}from"./vendor-9e8ed699.js";const i=({key:e,name:t,rounds:o,showCards:n}={})=>({key:e||null,name:t||"",rounds:o||[{}],showCards:n||!1}),P=I.exports.Deta("b0ouklc5_23zArb8iPdWFe3ZQGbd7x86gjBedFbfo"),u=P.Base("planningPoker_Rooms"),p=()=>typeof window!="undefined",v=({rooms:e=[],currentRoom:t=i()}={})=>({rooms:e,currentRoom:t,cardPattern:p()&&localStorage.getItem("cardPattern")}),B=(()=>{let e=v();const{subscribe:t,set:o,update:n}=x(e);return t(r=>{e=r}),{subscribe:t,set:o,update:n,setCardPattern(r){if(!p())return;const c=localStorage.getItem("id"),m=e.currentRoom.rounds.length-1,d=e.currentRoom.rounds[m]||{};o(a(s({},e),{cardPattern:r})),localStorage.setItem("cardPattern",r),d[c]&&this.chooseCard(d[c].value)},async fetchRooms(){return u.fetch().then(({items:r})=>o(a(s({},e),{rooms:r.map(i)})))},async saveRoom(r){const d=i(r),{key:c}=d,m=y(d,["key"]);return u.insert(m,c).finally(this.fetchRooms.bind(this))},async deleteRoom(r){return u.delete(r).finally(this.fetchRooms.bind(this))},async loadRoom(r){return u.get(r).then(c=>o(a(s({},e),{currentRoom:i(c)})))},async refreshCurrentRoom(){e.currentRoom.key&&this.loadRoom(e.currentRoom.key)},async toggleRevealCards(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{showCards:!e.currentRoom.showCards})});o(r),u.update({showCards:r.currentRoom.showCards},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async chooseCard(r){const c=localStorage.getItem("id"),m={playerName:localStorage.getItem("name"),pattern:e.cardPattern,value:r},d=e.currentRoom.rounds.length-1,C=e.currentRoom.rounds[d]||{},g=e.currentRoom.rounds.slice(0,d),w=a(s({},e),{currentRoom:a(s({},e.currentRoom),{rounds:[...g,a(s({},C),{[c]:m})]})});o(w),u.update({[`rounds[${d}].${c}`]:m},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async newRound(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{showCards:!1,rounds:[...e.currentRoom.rounds,{}]})});o(r),u.update({rounds:u.util.append({placeholder:!0}),showCards:!1},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))}}})();export{p as i,i as m,B as s};
