var w=Object.defineProperty,k=Object.defineProperties;var I=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var y=(o,t,e)=>t in o?w(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,s=(o,t)=>{for(var e in t||(t={}))i.call(t,e)&&y(o,e,t[e]);if(l)for(var e of l(t))h.call(t,e)&&y(o,e,t[e]);return o},a=(o,t)=>k(o,I(t));var f=(o,t)=>{var e={};for(var n in o)i.call(o,n)&&t.indexOf(n)<0&&(e[n]=o[n]);if(o!=null&&l)for(var n of l(o))t.indexOf(n)<0&&h.call(o,n)&&(e[n]=o[n]);return e};import{P as S,C as P}from"./vendor-9122012f.js";const R=({key:o,name:t,rounds:e,showCards:n}={})=>({key:o||null,name:t||"",rounds:e||[{}],showCards:n||!1}),x=S.exports.Deta("b0ouklc5_23zArb8iPdWFe3ZQGbd7x86gjBedFbfo"),d=x.Base("planningPoker_Rooms"),p=()=>typeof window!="undefined",v=({rooms:o=[],currentRoom:t=R()}={})=>({rooms:o,currentRoom:t,cardPattern:p()&&localStorage.getItem("cardPattern")}),B=(()=>{let o=v();const{subscribe:t,set:e,update:n}=P(o);return t(r=>{o=r}),{subscribe:t,set:e,update:n,setCardPattern(r){if(!p())return;const c=localStorage.getItem("id"),m=o.currentRoom.rounds.length-1,u=o.currentRoom.rounds[m]||{};e(a(s({},o),{cardPattern:r})),localStorage.setItem("cardPattern",r),u[c]&&(console.log("playerId",c),this.chooseCard(u[c].value))},async fetchRooms(){return d.fetch().then(({items:r})=>e(a(s({},o),{rooms:r.map(R)})))},async saveRoom(r){const u=R(r),{key:c}=u,m=f(u,["key"]);return d.insert(m,c).finally(this.fetchRooms.bind(this))},async deleteRoom(r){return d.delete(r).finally(this.fetchRooms.bind(this))},async loadRoom(r){return d.get(r).then(c=>e(a(s({},o),{currentRoom:R(c)})))},async refreshCurrentRoom(){o.currentRoom.key&&this.loadRoom(o.currentRoom.key)},async toggleRevealCards(){const r=a(s({},o),{currentRoom:a(s({},o.currentRoom),{showCards:!o.currentRoom.showCards})});e(r),d.update({showCards:r.currentRoom.showCards},o.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async chooseCard(r){const c=localStorage.getItem("id"),m={playerName:localStorage.getItem("name"),pattern:o.cardPattern,value:r},u=o.currentRoom.rounds.length-1,g=o.currentRoom.rounds[u]||{},C=o.currentRoom.rounds.slice(0,u),b=a(s({},o),{currentRoom:a(s({},o.currentRoom),{rounds:[...C,a(s({},g),{[c]:m})]})});e(b),d.update({[`rounds[${u}].${c}`]:m},o.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async newRound(){const r=a(s({},o),{currentRoom:a(s({},o.currentRoom),{rounds:[...o.currentRoom.rounds,{}]})});e(r),o.currentRoom,d.update({rounds:d.util.append({placeholder:!0})},o.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))}}})();export{p as i,R as m,B as s};
