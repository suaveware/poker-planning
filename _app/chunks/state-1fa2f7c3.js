var w=Object.defineProperty,k=Object.defineProperties;var I=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var y=(e,t,o)=>t in e?w(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,s=(e,t)=>{for(var o in t||(t={}))i.call(t,o)&&y(e,o,t[o]);if(l)for(var o of l(t))h.call(t,o)&&y(e,o,t[o]);return e},a=(e,t)=>k(e,I(t));var f=(e,t)=>{var o={};for(var n in e)i.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&l)for(var n of l(e))t.indexOf(n)<0&&h.call(e,n)&&(o[n]=e[n]);return o};import{P as S,C as P}from"./vendor-227c15ea.js";const R=({key:e,name:t,rounds:o,showCards:n}={})=>({key:e||null,name:t||"",rounds:o||[{}],showCards:n||!1}),x=S.exports.Deta("b0ouklc5_23zArb8iPdWFe3ZQGbd7x86gjBedFbfo"),d=x.Base("planningPoker_Rooms"),p=()=>typeof window!="undefined",v=({rooms:e=[],currentRoom:t=R()}={})=>({rooms:e,currentRoom:t,cardPattern:p()&&localStorage.getItem("cardPattern")}),B=(()=>{let e=v();const{subscribe:t,set:o,update:n}=P(e);return t(r=>{e=r}),{subscribe:t,set:o,update:n,setCardPattern(r){if(!p())return;const c=localStorage.getItem("id"),m=e.currentRoom.rounds.length-1,u=e.currentRoom.rounds[m]||{};o(a(s({},e),{cardPattern:r})),localStorage.setItem("cardPattern",r),u[c]&&(console.log("playerId",c),this.chooseCard(u[c].value))},async fetchRooms(){return d.fetch().then(({items:r})=>o(a(s({},e),{rooms:r.map(R)})))},async saveRoom(r){const u=R(r),{key:c}=u,m=f(u,["key"]);return d.insert(m,c).finally(this.fetchRooms.bind(this))},async deleteRoom(r){return d.delete(r).finally(this.fetchRooms.bind(this))},async loadRoom(r){return d.get(r).then(c=>o(a(s({},e),{currentRoom:R(c)})))},async refreshCurrentRoom(){e.currentRoom.key&&this.loadRoom(e.currentRoom.key)},async toggleRevealCards(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{showCards:!e.currentRoom.showCards})});o(r),d.update({showCards:r.currentRoom.showCards},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async chooseCard(r){const c=localStorage.getItem("id"),m={playerName:localStorage.getItem("name"),pattern:e.cardPattern,value:r},u=e.currentRoom.rounds.length-1,g=e.currentRoom.rounds[u]||{},C=e.currentRoom.rounds.slice(0,u),b=a(s({},e),{currentRoom:a(s({},e.currentRoom),{rounds:[...C,a(s({},g),{[c]:m})]})});o(b),d.update({[`rounds[${u}].${c}`]:m},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))},async newRound(){const r=a(s({},e),{currentRoom:a(s({},e.currentRoom),{rounds:[...e.currentRoom.rounds,{}]})});o(r),e.currentRoom,d.update({rounds:d.util.append({placeholder:!0})},e.currentRoom.key).finally(this.refreshCurrentRoom.bind(this))}}})();export{p as i,R as m,B as s};
